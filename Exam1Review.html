<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/274061; Windows/6.3.9600;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="6184"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>softwarecasestudy.org/dhartifactsgen.html</div><div><br/></div><div><b><u>Software Quality</u></b></div><div><b>Verification and Validation</b></div><div>Did we build the thing right? vs. Did we build the right thing? </div><div>Verification techniques:</div><div>     1) Testing</div><div>     2) Static analysis</div><div>     3) Inspection</div><div>     4) Software architect</div><div><br/></div><div><b>Types of Testing</b></div><div>1) Unit Testing</div><div>2) Integration Testing</div><div>3) Functional&amp;system testing</div><div>4) Acceptance testing</div><div>5) Beta testing</div><div>6) Regression testing</div><div><br/></div><div><b>Unit Testing, Test Cases</b></div><div>- Unit tests are written as code is written, before the code is made available to the rest of the team.</div><div>- If written before code - Test Driven Development!</div><div>- Benefits: Programmers write their own unit tests, get rapid response for testing small changes, support design flexibility and change, allows iterative development with working code early, gives you confidence in your code!</div><div>- Unit test Cons: Does not validate (not acceptance testing), doesn't let you know if all system components work together correctly (not integration testing) </div><div>- Red/Green/Refactor</div><div>Red: write a little test that doesn't work</div><div>Green: write code to make that test work quickly</div><div>Refactor: eliminate duplication and other problems you did just to make the test work. </div><div><b><br/></b></div><div><b>Test-Driven-Development</b></div><div><b>Code Coverage and Testing</b></div><div><b>Inspections; Fagan Inspections </b></div><div>The idea that it is difficult to catch our own mistakes.</div><div>But still need to proof read before giving to a peer!</div><div>Walkthrough inspection OR Fagan style inspection (see below)</div><div>Fagan style inspection - generally involves 3-6 participants, each with a particular role to play (or more than one role)</div><div>     <u>Author</u>: the person who created the document being inspected. Present at the inspection to answer questions but does not step through the work. </div><div>     <u>Moderator</u>: The moderator chooses the inspection team, schedules the inspection, distributes materials, etc.</div><div>     <u>Reader</u>: leads the inspection team through the software elements in a logical and comprehensive fashion. Paces the inspection.</div><div>     <u>Recorder</u> - Documents the defects in writing</div><div>     <u>Inspectors</u> - Raise questions and suggest problems with the document. </div><div><b><br/></b></div><div><b><u>SW Process Topics</u></b></div><div><b>What do we mean by SW process &amp; why does it matter?</b></div><div>The process by which user needs are turned into a product.</div><div><b>SW Process Models</b></div><div><b>     Ex. Waterfall, Spiral </b></div><div><b>SW Development Methodologies</b></div><div><b>     Plan-Driven vs Agile Development</b></div><div><b>Common issues: Role of things like iteration, risk management, prototyping, quality assurance</b></div><div><b>Risk Management</b></div><div>Things that happen during development that were not anticipated. </div><div><br/></div><div><u><strong>Configuration Management and Git</strong></u></div><div><strong>General terms and concepts for VCS and DVCS</strong></div><div>VCS - Version control system, a tool to track and manage changes to files.</div><div>     <u>Repository</u> - Place where VCS keeps tracks of changes.</div><div>     <u>Working copy</u> - Your current view of what's in the repository; when you're reading you commit a file to the repository.</div><div>     <u>Local repository</u> = on your machine</div><div>     <u>Remote, centralized repository</u> = on a server (Supports team development)</div><div><br/></div><div>DVCS - Distributed version control system</div><div>- Each developer has a local repository</div><div>- Central repository exists on network</div><div>- Push changes to central depository</div><div>- Pull others' changes</div><div>- Easy to move things between repositories</div><div>- i.e. Git, Mercurial</div><div><br/></div><div><strong>Creating repos with init or clone</strong></div><div>To create a local repository - in the folder, type  Git command <em>git init</em></div><div>Repository in the folder ./.git</div><div><br/></div><div>To start with files from other repository - type <em>git clone /path/to/repository</em> (for local)</div><div>or <em>git clone user@host:/path/to/repository</em> (for remote)</div><div><br/></div><div><strong>Git's commands: add, commit (Git's staging area, index)</strong></div><div>In your working tree, create a new file - to tell Git to control it: <em>git add &lt;filename&gt;</em></div><div>File is now in the <u>staging area</u> called the <u>index</u> (in between place/status, not yet committed to repo)</div><div>To move to <u>local repo</u>: <em>git commit -m &quot;log message&quot;</em> (groups of changes)</div><div><br/></div><div><strong>Local and remote repos, pull, push, fetch</strong></div><div><em>git pull</em> - Downloads files from remote repo</div><div><em>git push -</em> Uploads files to remote repo (sends current branch to remote repo)</div><div><em>fetch</em> - updates the remote branches on your machine; does not update your local branch; you can switch to the &quot;fetched&quot; branch (origin/master) and work there or merge it to your local branch.</div><div><em>pull</em> - fetch and merge in one operation.</div><div><br/></div><div><strong>Git branches, merge, resolving conflicts</strong></div><div>Each commit is a snapshot of the whole directory; but if a file is unchanged it just stores a link to the previous version.</div><div><u>Branch</u> - alternative history of commits</div><div>     <u>master</u> - &quot;normal&quot; branch</div><div>     Allows separate development to be done in a new direction on project files.</div><div>     In Git, it's a pointer to a commit.</div><div>Each repo has a unique set of branches; branches can be merged together.</div><div>Git handles most merging automatically, binary files and edits to same line of text files have to be handled manually.</div><div>Conflicts: must be added back to repository with &quot;add&quot; command. (Text you must resolve then add the file; non text use add on the file you want to use)</div><div><br/></div><div><strong>Typical workflow working with Git or other DVCS</strong></div><div>1) Start coding session, fetch code from shared remote repo</div><div>2) Merge that branch into local branch</div><div>3) Code, test files in your local branch</div><div>4) Commit code to local repo</div><div>5) Repeat 3&amp;4 until ready to share with others</div><div>6) Push code to shared remote repo. (Resolve any conflicts before push)</div><div><br/></div><div><b><u>Requirements</u></b></div><div><b>What is elicitation and how to do it?</b></div><div>Getting information about what the software needs to do! (and not how)</div><div><br/></div><div>Techniques: interviews, prototyping, scenarios, analysis of existing systems/documentation, asking marketers, etc.</div><div><br/></div><div><b>Functional vs Non Functional vs Constraints</b></div><div>Functional - requirements that specify a function that a system must do/be able to perform</div><div><br/></div><div>Non-functional - requirements which are not specifically concerned w/ the functionality of a system but place restrictions on the product being developed. (Usually called the &quot;-ities&quot;)</div><div>     Security, Privacy, Usability, Reliability, Availability, Performance</div><div>     Are measurable statements.</div><div><br/></div><div>Constraints - a type of nonfunctional requirement that is imposed by the client that restricts the implementation of the system or development process. (i.e. programming language, platform, hardware configuration.) </div><div><br/></div><div><b>Domain, System Context (System boundary, project scope)</b></div><div>Domain - the problem area for the proposed system, or several systems</div><div><br/></div><div>System context / system boundary / project scope - What is inside our system and what is outside. </div><div>Entities involved: input, output, events.</div><div><br/>
Important to define project scope! Which is what our system does or does not need to do. Viewing our system as a black box. </div><div><b><br/></b></div><div><b>Quality attributes for SW requirements statements</b></div><div><u>INVEST</u></div><div>Independent</div><div>Negotiable</div><div>Valuable</div><div>Estimable</div><div>Short</div><div>Testable </div><div><br/></div><div><b>Specification documents in </b><b>plan-driven methodologies (general ideas)</b></div><div><b><br/></b></div><div><b>Documentation techniques: Scenarios, Stories</b></div><div>Scenario - informal narrative story, simple, natural, personal, NOT generalizable, a CONCRETE use case.</div><div><br/></div><div>XP Stories - from extreme programming, a short description of system behavior from the user's point of view, written by customer &amp; developer together, focus on user needs, &quot;promises for conversation&quot; </div><div><br/></div><div>User Stories - Agile idea, follows a template: As a &lt;user type&gt; I want &lt;goal&gt; so that &lt;reason&gt;. </div><div>Very high level view. </div><div><br/></div><div><u><strong>Requirements Engineering (part 2)</strong></u></div><div><strong>Use cases: details, examples, how different than stories</strong></div><div>A sequence of actions a system performs to yield an observable result of value to a particular actor (someone/something outside the system that interacts with the system)</div><div>More formal definition than a scenario or story</div><div>More customer oriented than developer oriented</div><div>AKA task scenario, concrete use case / essential use case, use scenario</div><div><br/></div><div>Use cases vs SCRUM stories</div><div>- Use cases are better for designing user interfaces because they describe the function as a series of back and forth interactions</div><div>- SCRUM just tells you what to do</div><div>- Use cases have more detail and more organization.</div><div><br/></div><div>Includes Actors &amp; Use Cases, Pre- and Post- conditions, Normal vs. alternative behavior</div><div>Ex.</div><div>Use case # or id:</div><div>Use case title:</div><div>Text desc:</div><div>Actors:</div><div>Pre-conditions:</div><div>Flow of Events:</div><div>     Basic path:</div><div>          1.</div><div>          2.</div><div>          3.</div><div>     Alternative Paths:</div><div>          - Name and short desc (in words) of 1st alternative path/scenario</div><div>          - &quot;&quot;</div><div>Post-conditions:</div><div>Special conditions:</div><div><br/></div><div>Usually shows an interaction back and forth in the path: user, system, user, system, etc.</div><div><br/></div><div>Use case - family or class of scenarios</div><div>Scenarios - instance of a use case</div><div><br/></div><div><strong>Requirements specification: general principles</strong></div><div>Specification restates the requirements in technical terms so that the designer can start on the design; sometimes known as <em>developer oriented requirements</em></div><div>Both focus on requirements; what the system should do; functional &amp; non functional</div><div>BUT Specification activities are more developer oriented: output for designers, planning, quality assurance, rigorous modeling and documentation</div><div>Not useful for validation with the user, but for plans for future stages of development</div><div><br/></div><div><strong>Formal vs semi formal vs non formal forms of specification</strong></div><div>Natural language - expressive but ambiguous semantics</div><div>Semi-formal - SCR/tabular specs/UML/diagrams ; restricting, structuring natural language</div><div>Formal - VDM, CASL ; precise, mathematical semantics &amp; ACCURATE communication</div><div><br/></div><div><strong>     Problems with using natural language</strong></div><div><strong>     </strong>- Assumes everybody shares the same meaning</div><div>     - Ambiguous even if meanings are shared</div><div>     - No inherent structure</div><div>     - Same thing can be said many ways</div><div>     - Unsystematic; hard to effect change</div><div><br/></div><div>The higher the risk of the software the more necessary formal language is needed in requirements specification.</div><div><br/></div><div><u><strong>Security in SW Design</strong></u></div><div><strong>Confidentiality, integrity, availability (CIA)</strong></div><div>Three key security principles.</div><div><u>Confidentiality</u> - making sure data only viewable by authorized users</div><div>     Taking into account both data at rest and data in transit.</div><div>     Encryption is one method. (Symmetric &amp; asymmetric)</div><div><u>Integrity</u> - ensuring accuracy and consistency of data over its entire lifecycle</div><div>     Ensure integrity through hashing! or digital signatures</div><div><u>Availability</u> - data and services are available when needed, avoiding single points of failure</div><div><br/></div><div><strong>Authentication and Authorization</strong></div><div><u>A</u><u>uthentication</u> - confirming an identity, like password</div><div>     3 Main Types: something you know (PW, Pin), something you have (RSA keychain), something you are (biometrics)</div><div><u>Authorization</u> - specifying who or what type of user has access to certain system features &amp; data</div><div><strong>     Principle of least privilege (POLP)</strong></div><div><strong>     </strong>A concept used in operating system design; limiting access to the minimal level that will allow normal functioning. i.e. giving people the lowest level of user rights that they can have and still do their jobs.</div><div><br/></div><div><strong>Hash functions use to support integrity</strong></div><div>Algorithms such as MD5, SHA-1</div><div>Has to do w/ cryptography</div><div>Hashing the data you receive and comparing it with the hash of the original message; the hash of the original data must be provided to you in a secure fashion as well.</div><div><br/></div><div><strong>Security and requirements, including anti-requirements and abuse cases</strong></div><div>Many security issues center on inputs to the system; can you trust your input?</div><div>System boundary helps define what input is, which is determined during requirements activities.</div><div>Define functionality built into the system to support security; list specific security features</div><div><br/></div><div><u>Anti requirements</u> - thinking of things you DON'T want your system to do</div><div>     What threats are possible? Including security functions &amp; features or lack thereof. What happens when those fail or are circumvented?</div><div><br/></div><div><u>Abuse cases</u> - An interaction between the system and an actor, with harm resulting to the system, the actor, or other stakeholders. (could be an attacker or just a bad user.)</div><div><br/></div><div><u><strong>Python</strong></u></div><div><strong>modules, packages, package management, pip</strong></div><div>A module allows you to logically organize your Python code.</div><div>A Python object with arbitrarily named attributes that you can bind and reference.</div><div>A file consisting of Python code. A module can define functions, classes, variables, runnable code.</div><div>Definitions from a module can be <em>imported</em> into other modules</div><div><br/></div><div><u>Package</u> refers to a software component that works with our programming environment.</div><div>A <u>package manager</u> is a tool that downloads packages from a central repository for us, helps us keep packages updated, etc</div><div><br/></div><div>One package manager commonly used is called <u>pip</u></div><div>Using pip to install packages: in command line, type: &quot;pip3 install &lt;name of package&gt;</div><div><br/></div><div><strong>testing: assertions, what nose does, etc.</strong></div><div>nose runs tests on your code. </div><div>You can run both unit-test test classes but also simpler individual test functions you write (they just need to have a function name that starts with &quot;test&quot;)</div><div><br/></div><div>example:</div><div>def test_numbers_3_4():</div><div>    assert multiply(3,4) == 12</div><div>def test_strings_a_3():</div><div>     assert multiply('a', 3) == 'aaa'</div><div><br/></div><div>to run:</div><div>nosetests test_um_nose.py</div><div>nosetests -v test_um_nose.py</div><div><br/></div><div>setup() method runs before every test method</div><div>teardown() method runs after every test method</div><div><br/></div><div>unittests examples:</div><div>assertEqual(multiply(3,4,) , 12, &quot;It is supposed to return 12.&quot; )</div><div><br/></div><div>Same in nose, except with assert_equals</div><div><br/></div><div><strong>classes: constructors, common &quot;magic&quot; methods for len(), in, str(), etc.</strong></div><div>Magic methods are special methods, always surrounded by double underscores</div><div><u>Construction and Initialization</u></div><div>The way to define the initialization of an object.</div><div>when you call</div><div>x = SomeClass()</div><div>The first method that is called is <i>__new__(cls, [...)</i> which creates the instance and passes any arguments at creation into the initializer<i> __init__(self, [...) </i>. At the end of the object's lifespan, there's <i>__del__(self)</i></div><div><br/></div><div>__len__(self) - Returns the length of the container.</div><div>__str__(self) - Defines behavior for when str() is called on an instance of your class. String representation of a class.</div><div>__contains__(self, item) - Defines behavior for membership tests ; iterates over the sequence and returns True if it comes across the item it's looking for. </div><div>__iter__(self) - Return an iterator for the container. </div><div><strong><br/></strong></div><div><strong>lists and dictionaries, basic use / iterating over</strong></div><div><u>Lists</u> - defined by enclosing a sequence of items in square-brackets; E.g. my_list=[0, 1, &quot;hi&quot;, 3]</div><div>- Items can be different types</div><div>- Items indexed from 0; my_list[0] is the first item.</div><div>- A negative index counts back from the end ; my_list[-1] is the last item.</div><div>- Length of a list with len(my_list)</div><div>- Remove items using del() and add using append()</div><div><br/></div><div>Splice lets you get a subsequence of a list (or string).</div><div>my_list[i:j] refers to the subsequence from index i up to but not including j</div><div><br/></div><div>my_list[0, 1, &quot;hi&quot;, 3.14, &quot;there&quot;] </div><div>my_list[2:4] = &quot;hi&quot;, 3.14</div><div><br/></div><div>my_list[0:2] = my_list[-3:] updates my_list so the first two items are gone and a copy of the last 3 items take their place</div><div><br/></div><div><u>Dictionaries</u> - similar to hash tables / hash maps but simpler</div><div>- Must be initialize a variable to start off with. </div><div>dict = { }</div><div>dict2 = {key1: val1, key2: val2}</div><div><br/></div><div>- Use square bracket notation to access value for a key.</div><div>dict[key] = value</div><div><br/></div><div>- Several ways to iterate but perhaps easiest is with the items() function</div><div>for k,v in dict.items():</div><div>     print(k,v)</div></div>
</div></body></html> 